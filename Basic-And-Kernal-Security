[[Category:Security]]
[[Category:File systems]]
[[Category:Networking]]
[[fa:امنیت]]
[[ja:セキュリティ]]
[[ru:Security]]
{{Related articles start}}
{{Related|PAM}}
{{Related|Capabilities}}
{{Related|List of Applications/Security}}
{{Related|:Category:Security}}
{{Related articles end}}
This article contains recommendations and best practices for hardening an Arch Linux system.

== Concepts ==

* It ''is'' possible to tighten the security so much as to make your system unusable. The trick is to secure it without overdoing it.
* There are many other things that can be done to heighten the security, but the biggest threat is, and will always be, the user. When you think security, you have to think layers. When one layer is breached, another should stop the attack. But you can never make the system 100% secure unless you unplug the machine from all networks, lock it in a safe and never use it.
* Be a little paranoid. It helps. And be suspicious. If anything sounds too good to be true, it probably is!
* The [[Wikipedia:Principle of least privilege|principle of least privilege]]: each part of a system should only be able to access what is required to use it, and nothing more.

== Passwords ==

Passwords are key to a secure linux system. They secure your [[Users and groups|user accounts]], [[Disk encryption|encrypted filesystems]], and [[SSH keys|SSH]]/[[GPG]] keys. They are the main way a computer chooses to trust the person using it, so a big part of security is just about picking secure passwords and protecting them.

=== Choosing secure passwords ===

When relying on a passphrase, it must be complex enough to not be easily guessed from e.g. personal information, or [[Wikipedia:Password cracking|cracked]] using e.g. brute-force attacks. The tenets of strong passphrases are based on ''length'' and ''randomness''. In cryptography the quality of a passphrase is referred to as its [[Wikipedia:Entropic security]]. 

Insecure passwords include those containing:

* Personally identifiable information (e.g., your dog's name, date of birth, area code, favorite video game)
* Simple character substitutions on words (e.g., {{ic|k1araj0hns0n}})
* Root "words" or common strings followed or preceded by added numbers, symbols, or characters (e.g., {{ic|DG091101%}})
* Common phrases or short phrases of grammatically related words (e.g. {{ic|all of the lights}}), and even with character substitution.

The right choice for a password is something long (8-20 characters, depending on importance) and seemingly completely random.
A good technique for building secure, seemingly random passwords is to base them on characters from every word in a sentence.
Take for instance “the girl is walking down the rainy street” could be translated to {{ic|t6!WdtR5}} or, less simply, {{ic|t&6!RrlW@dtR,57}}.
This approach could make it easier to remember a password, but note that the the various letters have very different probabilities of being found at the start of words ([[Wikipedia:Letter frequency#Relative frequencies of the first letters of a word in the English language|Wikipedia:Letter frequency]]).

A better approach is to generate pseudo-random passwords with tools like {{Pkg|pwgen}} or {{Pkg|apg}}: for memorizing them, one technique (for ones typed often) is to generate a long password and memorize a minimally secure number of characters, temporarily writing down the full generated string. Over time, increase the number of characters typed - until the password is ingrained in muscle memory and need not be remembered. This technique is more difficult, but can provide confidence that a password will not turn up in wordlists or "intelligent" brute force attacks that combine words and substitute characters.

It is also very effective to combine these two techniques by saving long, complex random passwords with a [[List of applications/Security#Password managers|password manager]], which will be in turn accessed with a mnemonic password that will have to be used only for that purpose, especially avoiding to ever transmit it over any kind of network. This method of course limits the use of the stored passwords to the terminals where the database is available for reading (which on the other hand could be seen as an added security feature).

Also consider the [http://world.std.com/~reinhold/diceware.html Diceware Passphrase] method, using a sufficient number of words.

See Bruce Schneier's article [https://www.schneier.com/blog/archives/2014/03/choosing_secure_1.html Choosing Secure Passwords] or [http://www.iusmentis.com/security/passphrasefaq/ The passphrase FAQ] for some additional background. Also, you can check entropy level of your chosen passphrase [http://rumkin.com/tools/password/passchk.php here], or consulting [[Wikipedia:Password strength]].

=== Maintaining passwords ===

Once you pick a strong password, be sure to keep it safe. Watch out for [[Wikipedia:Social engineering (security)|manipulation]], [[Wikipedia:Shoulder surfing (computer security)|shoulder surfing]], and avoid reusing passwords so insecure servers cannot leak more information than necessary. [[List of applications/Security#Password managers|Password managers]] can help manage large numbers of complex passwords: if you are copy-pasting the stored passwords from the manager to the applications that need them, make sure to clear the copy buffer every time, and ensure they are not saved in any kind of log (e.g. do not paste them in plain terminal commands, which would store them in files like {{ic|.bash_history}}). [[Wikipedia:LastPass Password Manager|Lastpass]] is a service that stores encrypted passwords online for synchronization between devices, but requires that you trust both closed-source code and an external corporation. 

As a rule, do not pick insecure passwords just because secure ones are harder to remember. Passwords are a balancing act. It is better to have an encrypted database of secure passwords, guarded behind a key and one strong master password, than it is to have many similar weak passwords. Writing passwords down is perhaps equally effective[https://www.schneier.com/blog/archives/2005/06/write_down_your.html], avoiding potential vulnerabilities in software solutions while requiring physical security.

Another aspect of the strength of the passphrase is that it must not be easily recoverable from other places.
If you use the same passphrase for disk encryption as you use for your login password (useful e.g. to auto-mount the encrypted partition or folder on login), make sure that {{ic|/etc/shadow}} either also ends up on an encrypted partition, or uses a strong hash algorithm (i.e. sha512/bcrypt, not md5) for the stored password hash (see [[SHA password hashes]] for more info).

=== Password hashes ===

{{Expansion|Mention [[Wikipedia:Key derivation function|key derivation functions]], in particular PBKDF2, bcrypt and scrypt, how to use them, advantages and disadvantages, especially regarding custom-hardware-based brute-force attacks.|section=Removal of incorrect warning}}

By default, Arch stores the hashed user passwords in the root-only-readable {{ic|/etc/shadow}} file, separated from the other user parameters stored in the world-readable {{ic|/etc/passwd}} file, see [[Users and groups#User database]]. See also [[#Restricting root]].

Passwords are set with the '''passwd''' command, which [[Wikipedia:Key stretching|stretches]] them with the [[Wikipedia:Crypt (C)|crypt]] function and then saves them in {{ic|/etc/shadow}}. See also [[SHA password hashes]]. The passwords are also [[Wikipedia:Salt (cryptography)|salted]] in order to defend them against [[Wikipedia:Rainbow table|rainbow table]] attacks.

See also [http://www.slashroot.in/how-are-passwords-stored-linux-understanding-hashing-shadow-utils How are passwords stored in Linux (Understanding hashing with shadow utils)].

=== Enforcing strong passwords using pam_cracklib ===

''pam_cracklib'' provides protection against [[Wikipedia:Dictionary attack|Dictionary attacks]] and helps configure a password policy that can be enforced throughout the system.

{{Warning|The ''root'' account is not affected by this policy.}}
{{Note|You can use the ''root'' account to set a password for a user that bypasses the desired/configured policy. This is useful when setting temporary passwords.}}

If for example you want to enforce this policy:
* prompt 2 times for password in case of an error
* 10 characters minimum length (minlen option)
* at least 6 characters should be different from old password when entering a new one (difok option)
* at least 1 digit (dcredit option)
* at least 1 uppercase (ucredit option)
* at least 1 other character (ocredit option)
* at least 1 lowercase (lcredit option)

Edit the {{ic|/etc/pam.d/passwd}} file to read as:
{{bc|1=
#%PAM-1.0
password required pam_cracklib.so retry=2 minlen=10 difok=6 dcredit=-1 ucredit=-1 ocredit=-1 lcredit=-1
password required pam_unix.so use_authtok sha512 shadow
}}

The {{ic|password required pam_unix.so use_authtok}} instructs the ''pam_unix'' module to not prompt for a password but rather to use the one provided by ''pam_cracklib''.

You can refer to the pam_cracklib(8) and pam_unix(8) man pages for more information.

== Storage ==

=== Disk encryption ===

[[Disk encryption]], preferably full disk encryption with a [[#Passwords|strong passphrase]], is the only way to guard data against physical recovery. This provides complete security when the computer is turned off or the disks in question are unmounted.

Once the computer is powered on and the drive is mounted, however, its data becomes just as vulnerable as an unencrypted drive. It is therefore best practice to unmount data partitions as soon as they are no longer needed.

Certain programs, like [[Dm-crypt]], allow the user to encrypt a loop file as a virtual volume. This is a reasonable alternative to full disk encryption when only certain parts of the system need be secure.

=== File systems ===

{{Accuracy|You don't mount a partition, but a file system; i.e. this is not related to [[partitioning]]. In {{ic|fs.protected_hardlinks}} etc., the "fs" stands for "file system".}}

The kernel now prevents security issues related to hardlinks and symlinks if the {{ic|fs.protected_hardlinks}} and {{ic|fs.protected_symlinks}} sysctl switches are enabled, so there is no longer a major security benefit from separating out world-writable directories.

Partitions containing world-writable directories can still be kept separate as a coarse way of limiting the damage from disk space exhaustion. However, filling a partition like {{ic|/var}} or {{ic|/tmp}} is enough to take down services. More flexible mechanisms for dealing with this concern exist (like quotas), and some filesystems include related features themselves (btrfs has quotas on subvolumes).

==== Mount options ====

Following the principle of least privilege, filesystems should be mounted with the most restrictive mount options possible (without losing  functionality).

Relevant mount options are:

*{{ic|nodev}}: Do not interpret character or block special devices on the file system.
*{{ic|nosuid}}: Do not allow set-user-identifier or set-group-identifier bits to take effect.
*{{ic|noexec}}: Do not allow direct execution of any  binaries on the mounted filesystem.

Partitions used for data should always be mounted with {{ic|nodev}}, {{ic|nosuid}}, {{ic|noexec}}. Potential usage is presented in the table below.

{| class="wikitable"
| align="center" |'''Partition'''
| align="center" |{{ic|nodev}}
| align="center" |{{ic|nosuid}}
| align="center" |{{ic|noexec}}
|-
| {{ic|/var}}||yes||yes||yes <sup>[1]</sup>
|-
| {{ic|/home}}||yes||yes||yes, if you do not code, use wine or steam
|-
| {{ic|/dev/shm}}||yes||yes||yes
|-
| {{ic|/tmp}}||yes||yes||maybe, breaks compiling packages and various other things
|-
| {{ic|/boot}}||yes||yes||yes
|-
|}

<sup>[1]</sup> Note that some packages (building {{Pkg|nvidia-dkms}} for example) may require {{ic|exec}} on {{ic|/var}}.

=== File access permissions ===

The default [[file permissions]] allow read access to almost everything and changing the permissions can hide valuable information from an attacker who gains access to a non-root account such as the {{ic|http}} or {{ic|nobody}} users.

For example:

 # chmod 700 /boot /etc/{iptables,arptables}

The default [[Umask]] can be changed to improve security for newly created files. The [http://www.nsa.gov/ia/_files/os/redhat/rhel5-guide-i731.pdf NSA RHEL5 Security Guide] suggests a umask of {{ic|077}} for maximum security, which makes new files not readable by users other than the owner. To change this, see [[Umask#Set the mask value]].

== User setup ==

After installation make a normal user for daily use. Do not use the root user for daily use.

=== Lockout user after three failed login attempts ===

To further heighten the security it is possible to lockout a user after a specified number of failed login attempts. The user account can either be locked until the root user unlocks it, or automatically be unlocked after a set time.
To lockout a user for ten minutes after three failed login attempts you have to modify {{ic|/etc/pam.d/system-login}}:

{{hc|/etc/pam.d/system-login|
2=auth required pam_tally.so deny=2 unlock_time=600 onerr=succeed file=/var/log/faillog
#auth required pam_tally.so onerr=succeed file=/var/log/faillog
}}

If you do not comment the second line every failed login attempt will be counted twice. That is all there is to it. If you feel adventurous, make three failed login attempts. Then you can see for yourself what happens. To unlock a user manually do:

 # pam_tally --user ''username'' --reset

If you want to permanently lockout a user after 3 failed login attempts remove the {{ic|unlock_time}} part of the line. The user can then not login until root unlocks the account.

=== Limit amount of processes ===

On systems with many, or untrusted users, it is important to limit the number of processes each can run at once, therefore preventing [[Wikipedia:Fork bomb|fork bombs]] and other denial of service attacks. {{ic|/etc/security/limits.conf}} determines how many processes each user, or group can have open, and is empty (except for useful comments) by default. adding the following lines to this file will limit all users to 100 active processes, unless they use the {{ic|prlimit}} command to explicitly raise their maximum to 200 for that session. These values can be changed according to the appropriate number of processes a user should have running, or the hardware of the box you are administrating. 

 * soft nproc 100
 * hard nproc 200

== Restricting root ==

The root user is, by definition, the most powerful user on a system. Because of this, there are a number of ways to keep the power of the root user while limiting its ability to cause harm, or at least to make root user actions more traceable.

=== Use sudo instead of su ===

Using [[sudo]] for privileged access is preferable to [[su]] for [[Su#Security|a number of reasons]].

* It keeps a log of which normal privilege user has run each privileged command.
* The root user password need not be given out to each user who requires root access.
* {{ic|sudo}} prevents users from accidentally running commands as ''root'' that do not need root access, because a full root terminal is not created. This aligns with the [[Wikipedia:Principle of least privilege|principle of least privilege]].
* Individual programs may be enabled per user, instead of offering complete root access just to run one command. For example, to give the user ''alice'' access to a particular program:

 # visudo

{{hc|/etc/sudoers|
alice ALL &#61; NOPASSWD: /path/to/program}}

Or, individual commands can be allowed for all users. To mount Samba shares from a server as a regular user:

 %users ALL=/sbin/mount.cifs,/sbin/umount.cifs

This allows all users who are members of the group users to run the commands {{ic|/sbin/mount.cifs}} and {{ic|/sbin/umount.cifs}} from any machine (ALL).

{{Tip|
To use {{ic|nano}} instead of {{ic|vi}} with {{ic|visudo}},

{{hc|/etc/sudoers|
2=Defaults editor=/usr/bin/rnano
}}

Exporting {{ic|1=# EDITOR=nano visudo}} is regarded as a severe security risk since everything can be used as an {{ic|EDITOR}}.
}}

==== Editing files using sudo ====

Running a text editor as root can be a security vulnerability as many editors can run arbitrary shell commands or affect files other than the one you intend to edit. To avoid this, use {{ic|sudoedit filename}} (equivalently, {{ic|sudo -e filename}}) to edit files. This edits a copy of the file using your normal user privileges and then overwrites the original using sudo only after the editor is closed. You can change the editor this uses by setting the {{ic|SUDO_EDITOR}} environment variable:

 export SUDO_EDITOR=vim

Alternatively, use an editor like {{ic|rvim}} which has restricted capabilities in order to be safe to run as root.

=== Restricting root login ===

Once [[sudo]] is properly configured, full root access can be heavily restricted or denied without losing much usability. To disable root, but still allowing to use [[sudo]], you can use {{ic|passwd -l root}}.

==== Allow only certain users ====

The [[PAM]] {{ic|pam_wheel.so}} lets you allow only users in the group {{ic|wheel}} to login using {{ic|su}}. Edit both {{ic|/etc/pam.d/su}} and {{ic|/etc/pam.d/su-l}}, then uncomment the line:

{{bc|<nowiki>
# Uncomment the following line to require a user to be in the "wheel" group.
auth		required	pam_wheel.so use_uid
</nowiki>}}

This means only users who are already able to run privileged commands may login as root.

==== Denying ssh login ====

Even if you do not wish to deny root login for local users, it is always good practice to [[Ssh#Deny|deny root login via SSH]]. The purpose of this is to add an additional layer of security before a user can completely compromise your system remotely.

==Mandatory access control==

[[Wikipedia:Mandatory Access Control|Mandatory access control]] (MAC) is a type of security policy that differs significantly from the [[Wikipedia:Discretionary Access Control|discretionary access control]] (DAC) used by default in Arch and most Linux distributions. MAC essentially means that every action a program could perform that affects the system in any way is checked against a security ruleset. This ruleset, in contrast to DAC methods, cannot be modified by users. Using virtually any mandatory access control system will significantly improve the security of your computer, although there are differences in how it can be implemented.

=== Pathname MAC ===

Pathname-based access control is a simple form of access control that offers permissions based on the path of a given file. The downside to this style of access control is that permissions are not carried with files if they are moved about the system. On the positive side, pathname-based MAC can be implemented on a much wider range of filesystems, unlike labels-based alternatives.

*[[AppArmor]] is a [[Wikipedia:Canonical|Canonical]]-maintained MAC implementation seen as an "easier" alternative to SELinux.
*[[Tomoyo]] is another simple, easy-to-use system offering mandatory access control. It is designed to be both simple in usage and in implementation, requiring very few dependencies.

=== Role-based access control ===

The MAC implementation grsecurity supports is called role-based access control. RBAC associates roles with each user. Each role defines what operations can be performed on certain objects. Given a well-written collection of roles and operations your users will be restricted to perform only those tasks that you tell them they can do. The default "deny-all" ensures you that a user cannot perform an action you have not thought of.

*[[Grsecurity#RBAC|Grsecurity RBAC]] has a learning mode like AppArmor for easy configuration
*[[Grsecurity#RBAC|Grsecurity RBAC]] does not rely on extra meta-data like SELinux. RBAC is significantly faster then SELinux.

=== Labels MAC ===

Labels-based access control means the extended attributes of a file are used to govern its security permissions. While this system is arguably more flexible in its security offerings than pathname-based MAC, it only works on filesystems that support these extended attributes.

*[[SELinux]], based on a [[Wikipedia:NSA|NSA]] project to improve Linux security, implements MAC completely separate from system users and roles. It offers an extremely robust multi-level MAC policy implementation that can easily maintain control of a system that grows and changes past its original configuration.

=== Access Control Lists ===

[[Access Control Lists]] (ACLs) are an alternative to attaching rules directly to the filesystem in some way. ACLs implement access control by checking program actions against a list of permitted behavior.

*[[grsecurity]] implements ACL access control, as well as a complete kernel patchset focused on improving security. Its changes extend to control of memory allocation, improved chroot restrictions, and rules involving specific network behavior.

== Kernel hardening ==

=== Restricting access to kernel logs ===

The kernel logs contain useful information for an attacker trying to exploit kernel vulnerabilities, such as sensitive memory addresses. The {{ic|kernel.dmesg_restrict}} flag was to forbid access to the logs without the {{ic|CAP_SYS_ADMIN}} capability (which only processes running as root have by default).

{{hc|/etc/sysctl.d/50-dmesg-restrict.conf|2=kernel.dmesg_restrict = 1}}

=== Restricting access to kernel pointers in the proc filesystem ===

Enabling {{ic|kernel.kptr_restrict}} will hide kernel symbol addresses in {{ic|/proc/kallsyms}} from regular users without {{ic|CAP_SYSLOG}}, making it more difficult for kernel exploits to resolve addresses/symbols dynamically. This will not help that much on a pre-compiled Arch Linux kernel, since a determined attacker could just download the kernel package and get the symbols manually from there, but if you're compiling your own kernel, this can help mitigating local root exploits. This will break some {{Pkg|perf}} commands when used by non-root users (but many {{Pkg|perf}} features require root access anyway). See {{Bug|34323}} for more information.

{{hc|/etc/sysctl.d/50-kptr-restrict.conf|2=kernel.kptr_restrict = 1}}

=== Keep BPF JIT compiler disabled ===

The Linux kernel includes the ability to compile BPF/Seccomp rule sets to native code as a performance optimization. The {{ic|net.core.bpf_jit_enable}} flag should be left at 0 for a maximum level of security.

This can be helpful in specific domains, but is not usually useful. A JIT compiler opens up the possibility for an attacker to perform a heap spraying attack, where they fill the kernel's heap with malicious code. This code can then potentially be executed via another exploit, like an incorrect function pointer dereference.

{{note|[[grsecurity]] includes JIT hardening for the BPF JIT compiler, greatly reducing the risk of exploitation.}}

=== ptrace scope ===

Arch enables the Yama LSM by default, providing a {{ic|kernel.yama.ptrace_scope}} flag. This flag is enabled by default and prevents processes from performing a {{ic|ptrace}} call on other processes outside of their scope without {{ic|CAP_SYS_PTRACE}}. While many debugging tools require this for some of their functionality, it is a significant improvement in security. Without this feature, there is essentially no separation between processes running as the same user without applying extra layers like namespaces. The ability to attach a debugger to an existing process is a demonstration of this weakness.

{{note|In [[grsecurity]], this protection is toggled via the {{ic|kernel.grsecurity.harden_ptrace}} flag instead.}}

==== Examples of broken functionality ====

{{Note|You can still execute these commands as root (such as allowing them through [[sudo]] for certain users, with or without a password), or enable ptrace selectively through {{ic|1=setcap cap_sys_ptrace=eip ''/path/to/program''}}.}}

* {{ic|gdb -p $PID}}
* {{ic|strace -p $PID}}
* {{ic|perf trace -p $PID}}
* {{ic|reptyr $PID}}

=== hidepid ===

The kernel has the ability to hide other users' processes from unprivileged users by mounting the {{ic|proc}} filesystem with {{ic|1=hidepid=1}} or {{ic|1=hidepid=2}}. This can be automated with the {{pkg|hidepid}} package. It will install polkit and systemd-logind exceptions and make sure {{ic|/proc}} is mounted with {{ic|1=hidepid=2,gid=26}}.

=== grsecurity ===

The [[grsecurity]] kernel provides many security-related improvements. It hardens both the kernel and userspace against common memory corruption vulnerabilities, along with providing many miscellaneous features and a role-based access control system. It is the only way to secure the kernel itself against exploitation, which is the most important improvement for a system already making good use of user isolation, containers/chroots and sandboxes.

== Sandboxing applications ==

=== Firejail ===

[[Firejail]] is an easy to use and simple tool for sandboxing applications and servers alike. Firejail is suggested for browsers and internet facing applications, as well as any servers you may be running. Firejail is further enhanced when used with Grsecurity.

{{Tip|If you do not require to sandbox graphical applications, an alternative is {{Pkg|playpen}}.}}

=== chroots ===

Manual [[chroot]] jails can also be constructed.

=== Linux containers ===

[[Linux Containers]] are another good option when you need more separation than the other options (short of KVM and Virtualbox) provide. LXC's run on top of the existing kernel in a pseudo-chroot with their own virtual hardware.

=== Other virtualization options ===

Using other, more full virtualization options such as [[VirtualBox]], [[KVM]], or [[Xen]] can also improve security in the event you plan on running risky applications or browsing dangerous websites.

== Network and firewalls ==

=== Firewalls ===

While the stock Arch kernel is capable of using [[Wikipedia:Netfilter|Netfilter]]'s [[iptables]], it is not enabled by default. It is highly recommended to set up some form of firewall to protect the services running on the system. Many resources (including ArchWiki) do not state explicitly which services are worth protecting, so enabling a firewall is a good precaution.

*See [[iptables]] for general info.
*See [[Simple stateful firewall]] for a guide on setting up an iptables firewall.
*See [[Firewalls]] for other ways of setting up netfilter.
*See [[Ipset]] for blocking lists of ip addresses, such as those from Bluetack.

=== Kernel parameters ===

Kernel parameters which affect networking can be set using [[Sysctl]]. For how to do this, see [[Sysctl#TCP/IP stack hardening]].

=== SSH ===

Avoid using [[Secure Shell]] without [[Secure Shell#Force public key authentication|requiring SSH keys]]. This prevents [[Wikipedia:Brute-force attack|brute-force attacks]]. Alternatively [[Fail2ban]] or [[Sshguard]] offer lesser forms of protection by monitoring logs and writing [[Iptables|iptables rules]] but open up the potential for a denial of serving, since an attacker can spoof packets as if they came from the administrator after identifying their address.

You may want to harden authentication even more by using two-factor authentication. [[Google Authenticator]] provides a two-step authentication procedure using one-time passcodes (OTP).

[[Secure Shell#Deny|Denying root login]] is good practice, both for tracing intrusions and adding an additional layer of security before root access.

===DNS===

See [[DNSSEC]] and [[DNSCrypt]].

=== Proxies ===

Proxies are commonly used as an extra layer between applications and the network, sanitizing data from untrusted sources. The attack surface of a small proxy running with lower privileges is significantly smaller than a complex application running with the end user privileges.

For example the DNS resolver is implemented in {{Pkg|glibc}}, that is linked with the application (that may be running as root), so a bug in the DNS resolver might lead to a remote code execution. This can be prevented by installing a DNS caching server, such as [[Dnsmasq]], which acts as a proxy. [https://googleonlinesecurity.blogspot.it/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html]

=== Managing SSL certificates ===

See [[OpenSSL]] and [[Network Security Services]] (NSS) for managing custom server-side SSL certificates. Notably, the related [[Let’s Encrypt]] project is also supported. 

The default internet SSL certificate trustchains are provided by the {{Pkg|ca-certificates}} package and its dependencies. Note that Arch relies on trust-sources (e.g. {{Pkg|ca-certificates-cacert}}, {{Pkg|ca-certificates-mozilla}}) providing the certificates to be trusted per default by the system. 

There may be occasions when you want to deviate from the default. For example, you may read some [http://www.theregister.co.uk/2016/05/27/blue_coat_ca_certs/ news] and want to distrust a certificate rather than wait until the trust-source providers do. The Arch infrastructure makes such easy: 
# Obtain the respective certificate in .crt format (Example: [https://crt.sh/?id=19538258 view], [https://crt.sh/?d=19538258 download]; in case of an existing trusted root certificate authority, you may also find it extracted in the system path), 
# Copy it to {{ic|/etc/ca-certificates/trust-source/blacklist/}} and 
# Run ''update-ca-trust'' as root. 

To check the blacklisting works as intended, you may re-open your preferred browser and do so via its GUI, which should show it as '''untrusted''' now.

== Authenticating packages ==

[http://www.cs.arizona.edu/stork/packagemanagersecurity/attacks-on-package-managers.html#overview Attacks on package managers] are possible without proper use of package signing, and can affect even package managers with [http://www.cs.arizona.edu/stork/packagemanagersecurity/faq.html proper signature systems]. Arch uses package signing by default and relies on a web of trust from 5 trusted master keys. See [[Pacman-key]] for details.

== Follow NVD/CVE alerts ==

Subscribe to the Common Vulnerabilities and Exposure (CVE) Security Alert updates, made available by National Vulnerability Database, and found on the [http://nvd.nist.gov/download.cfm NVD Download webpage]. The [https://security.archlinux.org/ Arch Linux Security Tracker] serves as a particularly useful resource in that it combines Arch Linux Security Advisory (ASA), Arch Linux Vulnerability Group (AVG) and CVE data sets in tabular format. See also [[Arch CVE Monitoring Team]] and [[CVE]].
{{Warning|Do not be tempted to perform [[partial upgrades]], as they are not supported by Arch Linux and may cause instability: the whole system should be upgraded when upgrading a component. Also note that infrequent system updates can complicate the update process.}}

== Physical security ==

{{Note|You can ignore this section if you just want to secure your computer against remote threats.}}

Physical access to a computer is root access given enough time and resources. However, a high ''practical'' level of security can be obtained by putting up enough barriers.

An attacker can gain full control of your computer on the next boot by simply attaching a malicious IEEE 1394 (FireWire), Thunderbolt or PCI Express device as they are given full memory access.[http://www.breaknenter.org/projects/inception/] There is little you can do from preventing this, or modification of the hardware itself - such as flashing malicious firmware onto a drive. However, the vast majority of attackers will not be this knowledgeable and determined.

[[#Disk encryption]] will prevent access to your data if the computer is stolen, but malicious firmware can be installed to obtain this data upon your next log in by a resourceful attacker.

=== Locking down BIOS ===

Adding a password to the BIOS prevents someone from booting into removable media, which is basically the same as having root access to your computer. You should make sure your drive is first in the boot order and disable the other drives from being bootable if you can.

=== Bootloaders ===

It is highly important to protect your bootloader. There is a magic kernel parameter called {{ic|1=init=/bin/sh}}. This makes any user/login restrictions totally useless.

==== Syslinux ====

Syslinux supports [[Syslinux#Security|password-protecting your bootloader]].
It allows you to set either a per-menu-item password or a global bootloader password.

==== GRUB ====

[[GRUB]] supports bootloader passwords as well. See [[GRUB/Tips and tricks#Password protection of GRUB menu]] for details. It also has support for [[GRUB#Boot_partition|encrypted boot partitions]], which only leaves some parts of the bootloader code unencrypted. GRUB's configuration, [[kernel]] and [[initramfs]] are encrypted.

=== Denying console login as root ===

Changing the configuration to disallow root to login from the console makes it harder for an intruder to gain access to the system. The intruder would have to guess both a username that exists on the system and that user's password. When root is allowed to log in via the console, an intruder only needs to guess a password.
Blocking root login at the console is done by commenting out the tty lines in {{ic|/etc/securetty}}.
{{hc|/etc/securetty|
#tty1
}}

Repeat for any tty you wish to block.
To check the effect of this change, start by commenting out only one line and go to that particular console and try to login as root. You will be greeted by the message {{ic|Login incorrect}}. Now that we are sure it works, go back and comment out the rest of the tty lines.
{{Note|If you see {{ic|ttyS0}} this is for a serial console. Similarly, on Xen virtualized systems {{ic|hvc0}} is for the administrator.}}

=== Automatic logout ===

If you are using [[Bash]] or [[Zsh]], you can set {{ic|TMOUT}} for an automatic logout from shells after a timeout.

For example, the following will automatically log out from virtual consoles (but not terminal emulators in X11):

{{hc|/etc/profile.d/shell-timeout.sh|<nowiki>
TMOUT="$(( 60*10 ))";
[ -z "$DISPLAY" ] && export TMOUT;
case $( /usr/bin/tty ) in
	/dev/tty[0-9]*) export TMOUT;;
esac
</nowiki>}}

If you really want EVERY Bash/Zsh prompt (even within X) to timeout, use:

 $ export TMOUT="$(( 60*10 ))";

Note that this will not work if there is some command running in the shell (eg.: an SSH session or other shell without {{ic|TMOUT}} support). But if you are using VC mostly for restarting frozen GDM/Xorg as root, then this is very useful.

== Rebuilding packages ==

Packages can be rebuilt and stripped of undesired functions and features as a means to reduce attack surface. For example, {{Pkg|bzip2}} can be rebuilt without {{ic|bzip2recover}} in an attempt to circumvent [https://security.archlinux.org/CVE-2016-3189 CVE-2016-3189]. Custom hardening flags can also be applied either manually or via {{Pkg|hardening-wrapper}}. 

=== Custom hardening flags ===

While still a work in progress, the following build flags can be enabled in {{Ic|/etc/makepkg.conf}} as they are expected to become [https://lists.archlinux.org/pipermail/arch-dev-public/2016-October/028405.html Arch default] flags in the future:

* {{Ic|z,now}} to LDFLAGS
* {{Ic|-fno-plt -fstack-check}} to [[Wikipedia:CFLAGS|CFLAGS]]

Using {{AUR|hardening-check}} to verify the status of the vanilla {{Ic|bzip2}} binary:

 $ hardening check -v /usr/bin/bzip2
 /usr/bin/bzip2:
 Position Independent Executable: no, normal executable!
 Stack protected: yes
 Fortify Source functions: no, only unprotected functions found!
        unprotected: fread
        unprotected: fprintf
        unprotected: strcat
        unprotected: strncpy
        unprotected: strcpy
 Read-only relocations: no, not found!
 Immediate binding: no, not found!

Using {{AUR|hardening-check}} to verify the status of a hardened {{Ic|bzip2}} ''binary'': 

 $ hardening check -v /usr/bin/bzip2
 /usr/bin/bzip2:
 Position Independent Executable: yes
 Stack protected: yes
 Fortify Source functions: yes (some protected functions found)
        unprotected: memcpy
        unprotected: fread
        unprotected: strncpy
        protected: fprintf
        protected: strcat
 Read-only relocations: yes
 Immediate binding: yes

Using {{Pkg|checksec}} to verify the status of the vanilla {{Ic|bzip2}} binary: 

 $ checksec -f /usr/bin/bzip2
 RELRO           STACK CANARY      NX                   PIE                RPATH        RUNPATH         FORTIFY Fortified Fortifiable  FILE
 No RELRO     Canary found         NX enabled     No PIE          No RPATH  No RUNPATH    Yes         0                    5        /usr/bin/bzip2

Using {{Pkg|checksec}} to verify the status of a hardened {{Ic|bzip2}} binary: 

 $ checksec -f /usr/bin/bzip2
 RELRO           STACK CANARY      NX                   PIE                RPATH        RUNPATH         FORTIFY Fortified Fortifiable  FILE
 Full RELRO    Canary found         NX enabled     PIE enabled  No RPATH  No RUNPATH   Yes         0                    5        /usr/bin/bzip2

{{Note|Certain packages are known to fail with PIE enabled. {{Ic|1=export HARDENING_PIE=0}} as a workaround.}}

== See also ==
* [[DeveloperWiki:Security]]
* [[List of applications/Security|ArchWiki: Security Applications]]
* [https://wiki.centos.org/HowTos/OS_Protection CentOS Wiki: OS Protection]
* [https://www.ibm.com/developerworks/linux/tutorials/l-harden-desktop/index.html Hardening the Linux desktop]
* [https://www.ibm.com/developerworks/linux/tutorials/l-harden-server/index.html Hardening the Linux server]
* [https://github.com/lfit/itpol/blob/master/linux-workstation-security.md Linux Foundation: Linux workstation security checklist]
* [https://www.privacytools.io/ privacytools.io Privacy Resources]
* [https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/ Red Hat Enterprise Linux 7 Security Guide]
* [https://www.debian.org/doc/manuals/securing-debian-howto/securing-debian-howto.en.pdf Securing Debian Manual (PDF)]
* [http://crunchbang.org/forums/viewtopic.php?id=24722 The paranoid #! Security Guide]
* [https://www.auscert.org.au/resources/publications/guidelines/unix-linux/unix-and-linux-security-checklist-v3.0 UNIX and Linux Security Checklist v3.0]
